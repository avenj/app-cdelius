#!perl

use Defaults::Modern;

use App::cdelius;
use App::cdelius::Component;
use App::cdelius::Exception;
use App::cdelius::Types -all;

my $Opts = +{
  help => sub {
  },

  version => sub {
  },

  config  => do {
    $ENV{HOME} ? $ENV{HOME} .'/.cdeliusrc'
      : 'cdeliusrc';
    },

  nocolor => 0,
};

use Getopt::Long;
GetOptions( $Opts,
  qw/
    help
    version

    config=s

    nocolor=i
  /,
);

fun getopts {
  state $argv = hash(%$Opts)->inflate;
  $argv
}

use Term::UI;
use Term::ReadLine;
use Text::ParseWords 'parse_line';

my $term   = Term::ReadLine->new('cdelius');
my $outfh  = $term->OUT || \*STDOUT;
$outfh->autoflush(1);


$outfh->say("Welcome to cdelius!\n");

unless (-e getopts->config) {
  my $should_create = $term->ask_yn(
    print_me =>
      ">>> No such file: ".getopts->config,
    prompt => 
      "Would you like to initialize a new configuration file?",
    default => 'y',
  );

  if ($should_create) {
    $outfh->print(" ... creating ".getopts->config);

    App::cdelius::Component
      ->build('Backend::Config')
      ->write_new_config(path => getopts->config);

    $outfh->print(" ... done\n");
  } else {
    $outfh->say(">> Continuing with defaults ...");
  }
}


fun app
  ( (Object | Undef) $cdel = undef ) {
    state $_cdel;
    $_cdel = $cdel if defined $cdel;

    $_cdel //= App::cdelius->new(
      config_file_path => getopts->config,
    )
}


fun list_is_dirty 
  ( (Bool | Undef) $is_dirty = undef ) {
    state $_is_dirty;
    $_is_dirty = $is_dirty if defined $is_dirty;

    $_is_dirty //= 0
}


define RET_LIST_DIRTY = -2;


PROMPT: while (1) {
  my $prompt = "cd> ";
  my $cmd    = $term->get_reply(
    prompt  => $prompt,
    default => 'help',
  );

  if ($cmd) {
    $term->addhistory($cmd);

    my ($optmap, $parsedcmd) = $term->parse_options($cmd);
    my ($thiscmd, @remain)  = parse_line('\s+', 0, $parsedcmd);

    dispatch( $thiscmd =>
      hash(%$optmap),
      array(@remain)
    ) if $thiscmd;
  }
}

fun dispatch (
  Str      $thiscmd,
  HashObj  $optmap,
  ArrayObj $args
) {
  my $subname = 'cmd_'.$thiscmd;
  my $code;
  unless ($code = __PACKAGE__->can($subname)) {
    $outfh->say("Unknown command $thiscmd, try 'help'");
    return
  }

  my $ret = $code->($optmap, $args);
  list_is_dirty(1) if $ret == RET_LIST_DIRTY;

  $ret
}



fun cmd_q    { goto \&cmd_quit }
fun cmd_quit 
  (HashObj $optmap, ArrayObj $args) {

    if (list_is_dirty) {
      my $do_save = $term->ask_yn(
        print_me => ">>> TrackList has unsaved changes",
        prompt => "Save this list before quitting?",
        default => 'y',
      );

      if ($do_save) {
       ## FIXME dispatch save
      }
    }

    $outfh->say("<< Goodbye!");

    exit 0
}

fun cmd_list 
  (HashObj $optmap, ArrayObj $args) {

    if ($args->has_any) {
      # FIXME list ranges, e.g. 'list 1 .. 5' or 'list 1 5'
    }
  
    my @tracks = app->tracklist->all;
    # FIXME iterate track objs and build pretty output
}

fun cmd_add
  (HashObj $optmap, ArrayObj $args) {

    unless ($args->has_any) {
      return dispatch( help => hash(), array('add') )
    }

    if ($args->count == 1) {
      # FIXME add $path syntax
    } elsif ($args->count == 2) {
      # FIXME add $path $position syntax
      #  check for valid position
    } else {
      # FIXME warn about too many args
    }
    # FIXME call $tlist->new_track(path => ...) to spawn obj,
    #  ->add_track to add
    # FIXME return RET_LIST_DIRTY if successful
}

fun cmd_del    { goto \&cmd_delete }
fun cmd_delete
  (HashObj $optmap, ArrayObj $args) {
    # FIXME syntax:
    #   del $index 
    # FIXME return RET_LIST_DIRTY if successful
}

fun cmd_move
  (HashObj $optmap, ArrayObj $args) {

    unless ($args->count == 2) {
      $outfh->say(">> Expected 2 args but got ".$args->count, "\n");
      return dispatch( help => hash(), array('move') )
    }

    my ($from, $to) = $args->all;

    unless ( is_Int $from ) {
      $outfh->say(">> Expected index Int but got $from");
      return
    }

    unless ( $from >= 0 && app->tracklist->get_track($from) ) {
      $outfh->say(">> No such track: $from");
      return
    }

    # move $from $to
    # move $from up
    # move $from down
    if ($to eq 'up') {
      my $target_pos = $from - 1;
      $target_pos    = 0 if $target_pos <= 0;
      app->tracklist->move_track(
        from_index => $from,
        to_index   => $target_pos
      )
    } elsif ($to eq 'down') {
      my $target_pos = $from + 1;
      my $last_pos   = array(app->tracklist->all)->count - 1;
      $target_pos    = $last_pos if $target_pos > $last_pos;
      app->tracklist->move_track(
        from_index => $from,
        to_index   => $target_pos,
      )
    } elsif (is_Int $to) {
      try {
        app->tracklist->move_track(
          from_index => $from,
          to_index   => $to
        );
        1
      } catch {
        $outfh->say(">> Backend reported error: $_");
        undef
      } or return;
    } else {
      $outfh->say(">> Unknown parameter $to");
      return dispatch( help => hash(), array('move') )
    }

    RET_LIST_DIRTY
}

fun cmd_load 
  (HashObj $optmap, ArrayObj $args) {
  # FIXME syntax:
  #   load $tlist_path
  # FIXME create new app($obj)
}

fun cmd_save
  (HashObj $optmap, ArrayObj $args) {
  # FIXME syntax:
  #   save (prompt if no ->path)
  #   save $path
  # FIXME set saved flag
}

fun cmd_h    { goto \&cmd_help }
fun cmd_help
  (HashObj $optmap, ArrayObj $args) {

  # FIXME help items + default
  state $help_for = hash(
    quit => array(),
    list => array(),
    add  => array(),
    del  => array(),
    move => array(),
    load => array(),
    save => array(),
  );

  if ($args->has_any) {
    # FIXME 'help $item' syntax
  }
}



# vim: ts=2 sw=2 et sts=2 ft=perl
